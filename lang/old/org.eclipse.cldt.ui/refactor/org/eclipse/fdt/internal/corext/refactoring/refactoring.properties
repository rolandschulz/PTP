###############################################################################
# Copyright (c) 2004 Rational Software Corporation and others.
# All rights reserved.   This program and the accompanying materials
# are made available under the terms of the Common Public License v0.5
# which accompanies this distribution, and is available at
# http://www.eclipse.org/legal/cpl-v05.html
# 
# Contributors: 
# IBM Rational Software - Initial API and implementation
###############################################################################
# NLS properties for the Refactoring Core

#######################################
# org.eclipse.jdt.internal.core.refactoring

Assert.assertion_failed=assertion failed; 
Assert.null_argument=null argument;

Checks.Choose_name=Choose a name
Checks.all_excluded=All resources have been excluded from refactoring. Cannot proceed
Checks.cannot_be_parsed=''{0}'' has syntax errors. Content of that file will not be updated.
Checks.cu_not_created=Translation unit could not be created for this element.
Checks.cu_not_parsed=This refactoring cannot be performed correctly due to syntax errors in the translation unit. To perform this operation you will need to fix the errors.
Checks.cu_has_compile_errors=Code modification may not be accurate as affected resource ''{0}'' has compile errors.
Checks.no_dot=Class name cannot contain a dot (.)
Checks.cu_name_used=translation unit ''{0}.java'' already exists
Checks.method_native=Method {0}::{1} is native. Running the modified program will cause {2}.
Checks.methodName.constructor=New method name has constructor name
Checks.methodName.exists=Method ''{0}'' already exists in type ''{1}''
Checks.methodName.overrides=New method ''{0}'' overrides existing method in type ''{1}''
Checks.methodName.returnTypeClash=New method ''{0}'' overrides a method declared in type ''{1}'' that uses a different return type.
Checks.has_main=Type {0} contains a main method - some applications (such as scripts) may not work after refactoring
Checks.constructor_name= If you proceed, the method {0} in ''{1}'' will have a constructor name.
Checks.method_names_lowercase=This name is discouraged. According to convention, names of methods should start with lowercase letters
Checks.error.InvalidClassName=Class name is not valid. {0}
Checks.warning.ClassNameDiscouraged=Class name is discouraged. {0}
Checks.no_files=No files are found.

#######################################
# org.eclipse.jdt.internal.core.refactoring.base
#######################################

Change.checking_for=Checking change for: {0}
Change.internal_Error=Internal Error
Change.is_unsaved={0} is unsaved
Change.is_read_only={0} is read only
Change.unexpected_exception=Unexpected exception while executing a change. See log for details.
Change.javaChanges= C changes


ChangeAbortException.wrapped=Exception wrapped by {0}

Refactoring.binary={0} is binary
Refactoring.not_in_model={0} does not exist in the model
Refactoring.read_only={0} is read only
Refactoring.unknown_structure={0} - unknown structure

#######################################
# org.eclipse.jdt.internal.core.refactoring.changes
#######################################
AbstractRenameChange.Renaming=Renaming...

RenameResourceChange.rename_resource=rename resource
RenameResourceChange.name=Rename ''{0}'' to: ''{1}''

CompositeChange.CompositeChange=CompositeChange>

DeleteFromClassPathChange.remove=Remove entry from classpath of C project:

MovePackageChange.move=Move package ''{0}'' to ''{1}''
MoveResourceChange.move=Move resource ''{0}'' to ''{1}''

RenameCProjectChange.rename=Rename C Project ''{0}'' to ''{1}''
RenameCProjectChange.update=Updating classpaths

RenameSourceFolderChange.rename=Rename Source Folder ''{0}'' to ''{1}''

AbstractCElementRenameChange.checking_change=Checking change for:

AbstractDeleteChange.deleting=deleting

CreatePackageChange.Creating_package=Creating package
CreatePackageChange.Create_package=Create package

AddToClasspathChange.add=Add entry to classpath of C project: 

CopyCompilationUnitChange.copy=Copy ''{0}'' to ''{1}''

CopyPackageChange.copy=Copy package ''{0}'' to ''{1}''

RenamePackageChange.checking_change=Checking change for: {0}
RenamePackageChange.name=Rename package ''{0}'' to ''{1}''

MoveCompilationUnitChange.default_package=(default package)
MoveCompilationUnitChange.name=Move Translation Unit ''{0}'' to ''{1}''

RenameCompilationUnitChange.name=Rename translation unit ''{0}'' to ''{1}''

#######################################
# org.eclipse.jdt.internal.core.refactoring.code
#######################################

#-- Extract Method -------------------------------------------
LocalTypeAnalyzer.local_type_from_outside=Selected block references a local type declared outside the selection.
LocalTypeAnalyzer.local_type_referenced_outside=A local type declared in the selected block is referenced outside the selection.

FlowAnalyzer.execution_flow=Selected statements contain a return statement but not all possible execution flows end in a return.

ExtractMethodAnalyzer.assignments_to_local=Ambiguous return value: selected block contains more than one assignment to local variable.
ExtractMethodAnalyzer.only_method_body=Cannot extract new method from selection. Only statements from a method body can be extracted.
ExtractMethodAnalyzer.after_do_keyword=Selection may not start immediately after the \'do\' keyword.
ExtractMethodAnalyzer.super_or_this=Cannot extract super or this call from constructor.
ExtractMethodAnalyzer.cannot_determine_return_type=Cannot determine expression's return type. Using void instead.
ExtractMethodAnalyzer.branch_mismatch=Selection contains branch statement but corresponding branch target is not selected.
ExtractMethodAnalyzer.parent_mismatch=Not all selected statements are enclosed by the same parent statement.
ExtractMethodAnalyzer.cannot_extract_anonymous_type=Cannot extract the body of a anonymous type declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_variable_declaration_fragment=Cannot extract a variable declaration fragment. Select whole declaration statement.
ExtractMethodAnalyzer.cannot_extract_for_initializer=Cannot extract initialization part of a for statement.
ExtractMethodAnalyzer.cannot_extract_for_updater=Cannot extract increment part of a for statement.
ExtractMethodAnalyzer.cannot_extract_variable_declaration=Cannot extract parts of a variable declaration. Select whole declaration.
ExtractMethodAnalyzer.cannot_extract_type_reference=Cannot extract a single type reference.
ExtractMethodAnalyzer.cannot_extract_name_in_declaration=Cannot extract the name part of a declaration.
ExtractMethodAnalyzer.ambiguous_return_value=Ambiguous return value: expression, access to local or return statement extracted.
ExtractMethodAnalyzer.compile_errors=The method''s body cannot be analyzed because of compilation errors in method ''{0}''. To perform the operation you will need to fix the errors.
ExtractMethodAnalyzer.leftHandSideOfAssignment=Cannot extract the left hand side of an assignment.
ExtractMethodAnalyzer.single_expression_or_set=Can only extract a single expression or a set of statements.
ExtractMethodAnalyzer.cannot_extract_null_type=Cannot extract null expression.

ExtractMethodRefactoring.name=Extract Method {0} in {1}
ExtractMethodRefactoring.add_method=add new method {0}
ExtractMethodRefactoring.checking_new_name=Checking new method name
ExtractMethodRefactoring.checking_selection=Checking text selection
ExtractMethodRefactoring.no_set_of_statements=Selection does not mark a set of statements. Only statements from a method body can be extracted.
ExtractMethodRefactoring.substitute_with_call=substitute statement(s) with call to {0}
ExtractMethodRefactoring.change_name=extract method {0} from method {1}
ExtractMethodRefactoring.organize_imports=Organize Imports
ExtractMethodRefactoring.duplicates.single=replace duplicate code fragment with call to {0}
ExtractMethodRefactoring.duplicates.multi=replace duplicate code fragments with call to {0}
ExtractMethodRefactoring.error.nameInUse=''{0}'' is already used as a name in the selected code
ExtractMethodRefactoring.error.sameParameter=A parameter ''{0}'' already exists

#-- Inline Method ------------------------------------------------------
InlineMethodRefactoring.name= Inline Method Refactoring
InlineMethodRefactoring.searching= Searching for references...
InlineMethodRefactoring.processing= Processing {0}
InlineMethodRefactoring.edit.inline= Inline invocation
InlineMethodRefactoring.edit.delete= Delete method declaration
InlineMethodRefactoring.edit.inlineCall= Inline Call
InlineMethodRefactoring.edit.import= Update import statements
InlineMethodRefactoring.error.classFile= Can\'t inline method since it is declared in a class file
InlineMethodRefactoring.error.noMethodDeclaration= Unable to resolve corresponding method declaration.
InlineMethodRefactoring.checking.overridden= Checking for overridden methods...
# The there keys below are referenced indirectly by passing a string to a helper
# method. So don't remove them even if they are marked as unused.
InlineMethodRefactoring.checking.overridden.error= Type {0} overrides method to be inlined.
InlineMethodRefactoring.checking.overrides.error= Method to be inlined overrides method from class {0}.
InlineMethodRefactoring.checking.implements.error= Method to be inlined implements method from interface {0}.

InlineMethodRefactoring.SourceAnalyzer.recursive_call=Method declaration contains recursive call.
InlineMethodRefactoring.SourceAnalyzer.declaration_has_errors=The method declaration contains compile errors. To perform the operation you will need to fix the errors.

InlineMethodRefactoring.SourceAnalyzer.qualified_this_expressions=Cannot inline a method that uses qualified this expressions.
InlineMethodRefactoring.SourceAnalyzer.syntax_errors=The translation unit containing this method declaration has syntax errors. To perform the operation you will need to fix the errors.
InlineMethodRefactoring.SourceAnalyzer.abstract_methods=Cannot inline abstract methods.

CallInliner.receiver_type=Can\'t determine receiver\'s type.
CallInliner.execution_flow=Can\'t inline method. Return statement in method declaration interrupts execution flow.
CallInliner.multiDeclaration=Can\'t inline method used as an initializer in a multi fragment variable declaration.
CallInliner.simple_functions=Inlining is only possible on simple functions (consisting of a single return statement), or functions used in an assignment.
CallInliner.field_initializer_simple=In field initializers inlining is only supported for simple functions (e.g. functions consisting of a single return statement).
CallInliner.field_initialize_new_local=Can\'t inline field initializer because new local variable is required.
CallInliner.field_initialize_write_parameter=Can\'t inline field initializer because one of the method parameters is used as an assignment target and will require new local variable.
CallInliner.field_initialize_self_reference=Can\'t inline method. Method references the field to be initialized.
CallInliner.constructors=Can\'t inline a constructor invocation that is used as a class instance creation.

#-- SEF ------------------------------------------------------
SelfEncapsulateField.AccessAnalyzer.encapsulate_read_access=Encapsulate read access
SelfEncapsulateField.AccessAnalyzer.encapsulate_write_access=Encapsulate write access
SelfEncapsulateField.AccessAnalyzer.encapsulate_prefix_access=Encapsulate prefix access
SelfEncapsulateField.AccessAnalyzer.encapsulate_postfix_access=Encapsulate postfix access
SelfEncapsulateField.AccessAnalyzer.cannot_convert_postfix_expression=Cannot convert postfix expression. It is used inside another expression.

SelfEncapsulateField.name=Self Encapsulate Field
SelfEncapsulateField.method_exists=A method ''{0}'' already exists in type ''{1}''.
SelfEncapsulateField.compiler_errors_field=Cannot analyze field ''{0}'' due to the following compiler error: {1}
SelfEncapsulateField.compiler_errors_update={0} contains compiler errors. This may affect field access update.
SelfEncapsulateField.type_not_resolveable=The type of the selected field cannot be resolved. An import statement may be missing.
SelfEncapsulateField.cannot_analyze_selected_field=Cannot analyze selected field ''{0}''
SelfEncapsulateField.checking_preconditions=Checking preconditions..
SelfEncapsulateField.searching_for_cunits=Searching for affected translation units...
SelfEncapsulateField.analyzing=Analyzing...
SelfEncapsulateField.create_changes=Create changes
SelfEncapsulateField.change_visibility=Change visibility to private
SelfEncapsulateField.add_setter=Add Setter method
SelfEncapsulateField.add_getter=Add Getter method

#-- inline temp ------------------------------------------------------
InlineTempRefactoring.name=Inline local variable
InlineTempRefactoring.syntax_errors=This translation unit contains syntax errors. To perform the operation you will need to fix the errors.
InlineTempRefactoring.select_temp=A local variable declaration or reference must be selected to activate this refactoring.
InlineTempRefactoring.method_parameter=Cannot inline method parameters.
InlineTempRefactoring.exceptions_declared=Cannot inline exceptions declared in \'catch\' clauses.
InlineTempRefactoring.not_initialized=Local variable ''{0}'' is not initialized at declaration.
InlineTempRefactoring.assigned_more_once=Local variable ''{0}'' is assigned more than once.
InlineTempRefactoring.preview=Creating preview
InlineTempRefactoring.inline=Inline local variable
InlineTempRefactoring.inline_edit_name=Inline local variable: 
InlineTempRefactoring.remove_edit_name=Remove local variable: 
InlineTempRefactoring.Array_vars_initialized=Array variables initialized with constants cannot be inlined.
InlineTempRefactoring.for_initializers=Cannot inline variables declared in the initializer list of a \'for\' statement.

#-- extract temp ------------------------------------------------------
ExtractTempRefactoring.name=Extract Local Variable
ExtractTempRefactoring.select_expression=An expression must be selected to activate this refactoring.
ExtractTempRefactoring.syntax_error=This file contains syntax errors. To perform this operation you will need to fix the errors.
ExtractTempRefactoring.explicit_constructor=Code from explicit constructor calls cannot be extracted to a variable.
ExtractTempRefactoring.expression_in_method=An expression used in a method must be selected to activate this refactoring.
ExtractTempRefactoring.no_void=Cannot extract an expression of type \'void\'.
ExtractTempRefactoring.null_literals=Cannot extract single null literals.
ExtractTempRefactoring.array_initializer=Operation not applicable to an array initializer.
ExtractTempRefactoring.assignment=Cannot extract assignment that is part of another expression.
ExtractTempRefactoring.single_conditional_expression=Currently no support to extract a single conditional expression.
ExtractTempRefactoring.convention=This name is discouraged. According to convention, names of local variables should start with lowercase letters.
ExtractTempRefactoring.checking_preconditions=Checking preconditions...
ExtractTempRefactoring.preview=Preparing preview
ExtractTempRefactoring.extract_temp=Extract Temp
ExtractTempRefactoring.update_imports=Update imports
ExtractTempRefactoring.declare_local_variable=Declare local variable
ExtractTempRefactoring.replace=Replace expression with a local variable reference
ExtractTempRefactoring.name_in_new=Cannot extract this name - try selecting the whole instance creation expression.
ExtractTempRefactoring.names_in_declarations=An expression has to be selected to activate this refactoring. Names used in declarations are not expressions.
ExtractTempRefactoring.assigned_to=The selected expression is assigned. Extracting may change the program\'s semantics.
ExtractTempRefactoring.refers_to_for_variable=Cannot extract expression, since it refers to a variable declared in the initializer of the enclosing \'for\' statement.
ExtractTempRefactoring.for_initializer_updater=Cannot extract \'for\' initializer or updater.

#-- extract constant --------------------------------------------------
ExtractConstantRefactoring.name=Extract Constant
ExtractConstantRefactoring.select_expression=An expression must be selected to activate this refactoring.
ExtractConstantRefactoring.syntax_error=This file contains syntax errors. To perform this operation you will need to fix the errors.
ExtractConstantRefactoring.declare_constant=Declare constant
ExtractConstantRefactoring.update_imports=Update imports
ExtractConstantRefactoring.replace=Replace expression with a constant reference
ExtractConstantRefactoring.preview=Preparing preview
ExtractConstantRefactoring.field_exists=Field ''{0}'' already exists.
ExtractConstantRefactoring.no_void=Cannot extract an expression of type \'void\'.
ExtractConstantRefactoring.null_literals=Cannot extract single null literals.
ExtractConstantRefactoring.not_load_time_constant=Cannot extract this expression - it is not a valid static constant.
ExtractConstantRefactoring.extract_constant=Extract Constant
ExtractConstantRefactoring.convention=This name is discouraged. According to convention, names of class constants do not contain lowercase letters.
ExtractConstantRefactoring.checking_preconditions=Checking preconditions...
ExtractConstantRefactoring.rename=Rename Constant

#-- introduce parameter --------------------------------------------------
IntroduceParameterRefactoring.name=Introduce Parameter
IntroduceParameterRefactoring.introduce_parameter=Introduce Parameter
IntroduceParameterRefactoring.syntax_error=This translation unit contains syntax errors. To perform the operation you will need to fix the errors.
IntroduceParameterRefactoring.select=An expression must be selected to activate this refactoring.
IntroduceParameterRefactoring.expression_in_method=An expression used in a method must be selected to activate this refactoring.
IntroduceParameterRefactoring.no_void=Cannot introduce a parameter from an expression of type \'void\'.
IntroduceParameterRefactoring.duplicate_name=A parameter or local variable with this name already exists.
IntroduceParameterRefactoring.preview=Preparing preview

IntroduceParameterRefactoring.add_parameter=Add parameter
IntroduceParameterRefactoring.replace=Replace expression with a parameter reference
IntroduceParameterRefactoring.add_argument=Add actual argument expression


#######################################
# org.eclipse.jdt.internal.core.refactoring.rename
#######################################
RenameCompilationUnitRefactoring.name=Rename ''{0}'' to ''{1}''
RenameCompilationUnitRefactoring.not_parsed={0} has syntax errors. No references will be updated if you proceed
RenameCompilationUnitRefactoring.not_parsed_1={0} has syntax errors.
RenameCompilationUnitRefactoring.same_name=The same name chosen

RenameFieldRefactoring.name=Rename field ''{0}'' to ''{1}''
RenameFieldRefactoring.hiding=After renaming, the field ''{0}'' will be hidden in the scope of the field ''{1}'' declared in type ''{2}''
RenameFieldRefactoring.hiding2=After renaming, the field named ''{0}'' declared in type ''{1}'' will be hidden in the scope of the field ''{2}''
RenameFieldRefactoring.another_name=Choose another name.
RenameFieldRefactoring.checking=Checking preconditions...
RenameFieldRefactoring.field_already_defined=Field with this name is already defined.
RenameFieldRefactoring.searching=Searching for references...
RenameFieldRefactoring.deleted=The selected field has been deleted from ''{0}''
RenameFieldRefactoring.already_exists=Method ''{0}'' already exists in ''{1}''
RenameFieldRefactoring.overridden=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.overridden_or_overrides=Method ''{0}'' is overridden or overrides another method
RenameFieldRefactoring.Update_getter_occurrence=Update getter occurrence
RenameFieldRefactoring.Update_setter_occurrence=Update setter occurrence
RenameFieldRefactoring.searching_for_text_matches=searching for text matches
RenameFieldRefactoring.Update_field_declaration=Update field declaration
RenameFieldRefactoring.Update_field_reference=Update field reference
RenameFieldRefactoring.should_start_lowercase=This name is discouraged. According to convention, C instance field names should start with lowercase letters
RenameFieldRefactoring.declared_in_supertype=Cannot be renamed because it is declared in a supertype

RenamePackageRefactoring.another_name=Choose another name.
RenamePackageRefactoring.checking=Checking preconditions...
RenamePackageRefactoring.creating_change=Preparing preview...
RenamePackageRefactoring.package_exists=Package already exists
RenamePackageRefactoring.searching=Searching for references...
RenamePackageRefactoring.update_reference=update package reference
RenamePackageRefactoring.name=Rename package ''{0}'' to ''{1}''
RenamePackageRefactoring.aleady_exists=Package ''{0}'' already exists in this project in folder ''{1}''

RenameMethodInInterfaceRefactoring.already_defined=A related type declares a method with the new name (and same number of parameters)
RenameMethodInInterfaceRefactoring.special_case=Cannot rename this method because it is a special case (see the language specification section 9.2 for details)

RenameMethodRefactoring.name=Rename method ''{0}'' to ''{1}''
RenameMethodRefactoring.no_binary=Related method ''{0}'' (declared in ''{1}'') is binary. Refactoring cannot be performed.
RenameMethodRefactoring.no_native=Renaming native methods will cause an unsatisfied link error on runtime.
RenameMethodRefactoring.no_native_1=Related method ''{0}'' (declared in ''{1}'') is native. Renaming will cause an UnsatisfiedLinkError on runtime.
RenameMethodRefactoring.no_read_only=Related method ''{0}'' (declared in ''{1}'') is read-only. Refactoring cannot be performed.
RenameMethodRefactoring.not_in_model=Related method ''{0}'' (declared in ''{1}'') does not exist in the model.
RenameMethodRefactoring.same_name=This name already exists.

RenamePrivateMethodRefactoring.hierarchy_defines=''{0}'' or a type in its hierarchy defines a method ''{1}'' with the same number of parameters and same parameter type names.
RenamePrivateMethodRefactoring.hierarchy_defines2=''{0}'' or a type in its hierarchy defines a method ''{1}'' with the same number of parameters, but different parameter type names.
RenamePrivateMethodRefactoring.update=Update method reference

RenameVirtualMethodRefactoring.requieres_renaming_native=Renaming ''{0}'' requires renaming a native method. Renaming will cause {1} on runtime.
RenameVirtualMethodRefactoring.hierarchy_declares1=Hierarchy declares a method ''{0}'' with the same number of parameters, but different parameter type names.
RenameVirtualMethodRefactoring.hierarchy_declares2=Hierarchy declares a method ''{0}'' with the same number of parameters and same parameter type names.

RenameMethodRefactoring.update_occurrence=Update method occurrence
RenameMethodRefactoring.update_declaration=Update method declaration
RenameMethodRefactoring.deleted=The selected method has been deleted from ''{0}''

RenameTypeRefactoring.checking=Checking preconditions...
RenameTypeRefactoring.choose_another_name=Please choose another name.
RenameTypeRefactoring.creating_change=Preparing preview...
RenameTypeRefactoring.rename_constructor=rename constructor
RenameTypeRefactoring.searching=Searching for references...
RenameTypeRefactoring.update_reference=update element reference
RenameTypeRefactoring.name=Rename ''{0}'' to ''{1}''
RenameTypeRefactoring.enclosed=Element ''{0}'' is enclosed in a type named ''{1}''
RenameTypeRefactoring.encloses=Element ''{0}'' encloses a type named ''{1}''
RenameTypeRefactoring.exists=Type named ''{0}'' already exists in package ''{1}''
RenameTypeRefactoring.imported=Type named ''{0}'' is imported (single-type-import) in ''{1}'' (a translation unit must not import and declare a type with the same name)
RenameTypeRefactoring.member_type_exists=Another element named ''{0}'' already exists in ''{1}''
RenameTypeRefactoring.global_member_type_exists=Another element named ''{0}'' already exists in the same element domain. This change might result in compilation errors.
RenameTypeRefactoring.enclosed_type_native=An element enclosed in type ''{0}'' declares a native method. Renaming will cause an unsatisfied link error on runtime.
RenameTypeRefactoring.name_conflict1=Name conflict with element ''{0}'' in ''{1}''
RenameTypeRefactoring.searching_text=searching for text matches
RenameTypeRefactoring.update=Type declaration update
RenameTypeRefactoring.does_not_exist=Element ''{0}'' does not exist in the saved version of ''{1}''
RenameTypeRefactoring.will_not_rename=Translation unit will not be renamed
RenameTypeRefactoring.local_type=Local Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.member_type=Member Type declared inside ''{0}'' is named {1}
RenameTypeRefactoring.another_type=Another type named ''{0} is referenced in ''{1}''
RenameTypeRefactoring.wrong_element=Rename refactoring does not handle this type of element.
RenameTypeRefactoring.virtual_method=Renaming a virtual method. Consider renaming the base and derived class methods (if any).



TextMatchFinder.comment=text reference update in a comment
TextMatchFinder.string=text reference update in a string literal
TextMatchFinder.searching=searching for text matches in:

RippleMethodFinder.analizing_hierarchy=analyzing hierarchy

RefactoringAnalyzeUtil.name_collision=Name collision with name ''{0}''

RenameTempRefactoring.must_select_local=A local variable declaration or reference must be selected to activate this refactoring
RenameTempRefactoring.only_in_methods_and_initializers=Only local variables declared in methods and initializers can be renamed
RenameTempRefactoring.lowercase=This name is discouraged. According to convention, local variable names should start with lowercase letters.
RenameTempRefactoring.rename=Rename Local Variable
RenameTempRefactoring.changeName=Rename local variable:''{0}'' to: ''{1}''

MethodChecks.overrides=The selected method overrides method ''{0}'' declared in type ''{1}''.
MethodChecks.implements=The selected method is an implementation of method ''{0}'' declared in type ''{1}''

RenameCProjectRefactoring.rename=Rename C project ''{0}'' to:''{1}''
RenameCProjectRefactoring.already_exists=A project with that name already exists
RenameCProjectRefactoring.read_only=Project ''{0}'' is marked as read-only

RenamePackageRefactoring.searching_text=searching for text matches
RenamePackageRefactoring.Packagered_only=Package ''{0}'' is read-only.
RenamePackageRefactoring.resource_read_only=Resource corresponding to package ''{0}'' is read only. Click ''Continue'' if still you want to rename it.
RenamePackageRefactoring.contains_type=Package ''{0}'' already contains a type named ''{1}''

RenameResourceRefactoring.Internal_Error=Internal Error
RenameResourceRefactoring.alread_exists=A file or folder with this name already exists
RenameResourceRefactoring.invalidName=This is an invalid name for a file or folder

RenameSourceFolderRefactoring.blank=Name must not start or end with a blank
RenameSourceFolderRefactoring.invalid_name=This is an invalid name for a file or folder
RenameSourceFolderRefactoring.already_exists=An element with this name already exists
RenameSourceFolderRefactoring.alread_exists=An element with this name already exists
RenameSourceFolderRefactoring.rename=Rename Source Folder ''{0}'' to ''{1}''

################ Rename Processors #########################################

RenameResourceProcessor.name=Rename resource ''{0}'' to ''{1}''

#######################################
# org.eclipse.jdt.internal.core.refactoring.reorg
#######################################
MoveRefactoring.reorganize_elements=Reorganize elements

DeleteRefactoring.delete_package_fragment_root= Deleting a package fragment root

MoveCuUpdateCreator.update_imports=update imports
MoveCuUpdateCreator.searching=Searching for references to types in ''{0}''
MoveCuUpdateCreator.update_references=update references

CopyRefactoring.cu.copyOf1=CopyOf{0}
CopyRefactoring.cu.copyOfMore=Copy_{0}_of_{1}
CopyRefactoring.resource.copyOf1=Copy of {0}
CopyRefactoring.resource.copyOfMore=Copy ({0}) of {1}
CopyRefactoring.package.copyOf1={0}.copy
CopyRefactoring.package.copyOfMore={1}.copy{0}

#######################################
# org.eclipse.jdt.internal.core.refactoring.structure
#######################################
PullUpRefactoring.Pull_Up=Pull Up
PullUpRefactoring.no_interface_members=Pull up is not allowed on interface members
PullUpRefactoring.no_java.lang.Object=Pull up is not allowed on elements declared in java.lang.Object
PullUpRefactoring.no_binary_types=Pull up is not allowed on elements declared in binary types
PullUpRefactoring.no_read_only_types=Pull up is not allowed on elements declared in read-only types
PullUpRefactoring.not_this_type=Pull up is not allowed on elements declared in this type
PullUpRefactoring.final_fields=Pulling up final fields will result in compilation errors if they are not initialized on creation or in constructors
PullUpRefactoring.checking_referenced_elements=Checking referenced elements
PullUpRefactoring.does_not_exist=Element {0} does not exist in the saved version of the file
PullUpRefactoring.type_not_accessible=Type ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PullUpRefactoring.different_method_return_type=Method ''{0}'' declared in type''{1}'' has a different return type than its pulled up counterpart, which will result in compile errors if you proceed
PullUpRefactoring.different_field_type=Field ''{0}'' declared in type ''{1}'' has a different type than its pulled up counterpart
PullUpRefactoring.static_method=Method ''{0}'' declared in type ''{1}'' is \'static\', which will result in compile errors if you proceed
PullUpRefactoring.lower_visibility=Method ''{0}'' declared in type ''{1}'' has visibility lower than \'protected\', which will result in compile errors if you proceed
PullUpRefactoring.preview=Preparing preview
PullUpRefactoring.calculating_required=Calculating required members
PullUpRefactoring.gets_instantiated=Class ''{0}'' cannot be made abstract because it gets instantiated
PullUpRefactoring.Field_declared_in_class=Field ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring.methodis_declared_in_class=Method ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.
PullUpRefactoring.field_cannot_be_accessed=Field ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring.method_cannot_be_accessed=Method ''{0}'' cannot be accessed from ''{1}''
PullUpRefactoring.Type_declared_in_class=Type ''{0}'' is declared in class ''{1}''. Pulling it up may result in changed program semantics.

MemberCheckUtil.signature_exists=Method ''{0}'' (with the same signature) already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil.same_param_count=Method ''{0}'' (with the same number of parameters) already exists in type ''{1}''
MemberCheckUtil.field_exists=Field ''{0}'' already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil.type_name_conflict0=Nested type ''{0}'' already exists in type ''{1}'', which will result in compile errors if you proceed
MemberCheckUtil.type_name_conflict1=Destination type has the same simple name as ''{0}'', which will result in compile errors if you proceed
MemberCheckUtil.type_name_conflict2=Destination type is enclosed in a type that has same simple name as ''{0}'', which will result in compile errors if you proceed
MemberCheckUtil.type_name_conflict3=Destination type has the same simple name as ''{0}'' (enclosed in ''{1}''), which will result in compile errors if you proceed
MemberCheckUtil.type_name_conflict4=Destination type is enclosed in a type that has same simple name as ''{0}'' (enclosed in ''{1}''), which will result in compile errors if you proceed

ChangeSignatureRefactoring.modify_Parameters=Change Method Signature
ChangeSignatureRefactoring.restructure_parameters=Restructure parameters
ChangeSignatureRefactoring.checking_preconditions=Checking preconditions...
ChangeSignatureRefactoring.method_deleted=The selected method has been deleted from ''{0}''
ChangeSignatureRefactoring.native=Method ''{0}'' declared in type ''{1}'' is native. Reordering parameters will cause UnsatisfiedLinkError on runtime if you do not update your native libraries
ChangeSignatureRefactoring.duplicate_name=Duplicate parameter name: {0}

MoveMembersRefactoring.Move_Members=Move Members
MoveMembersRefactoring.compile_errors=Operation can't be performed due to compile errors in ''{0}''. Please fix errors first.
MoveMembersRefactoring.deleteMembers= delete members
MoveMembersRefactoring.addMembers= add members
MoveMembersRefactoring.referenceUpdate= update reference to moved member
MoveMembersRefactoring.Checking_preconditions=Checking preconditions...
MoveMembersRefactoring.static_declaration=Static members can be declared only in top level or static types.
MoveMembersRefactoring.multi_var_fields=Currently, only field declarations with single variable declaration fragments can be moved.
MoveMembersRefactoring.only_public_static_final=Only ''public static final'' fields with variable initializers can be moved to an interface.
MoveMembersRefactoring.Object=Move is not allowed on members declared in 'java.lang.Object'.
MoveMembersRefactoring.binary=Pull up is not allowed on members of binary types.
MoveMembersRefactoring.read_only=Pull up is not allowed on members of read-only types.
MoveMembersRefactoring.move_members=Move members
MoveMembersRefactoring.not_found=Destination type ''{0}'' not be found
MoveMembersRefactoring.same=Destination and source types are the same (''{0}'')
MoveMembersRefactoring.inside=Destination type ''{1}'' is inside moved member''{0}''.
MoveMembersRefactoring.not_exist=Destination type ''{0}'' does not exist
MoveMembersRefactoring.dest_binary=Destination type ''{0}'' is binary
MoveMembersRefactoring.native=Moved method ''{0}'' is native. You will need to update native libraries.
MoveMembersRefactoring.moved_field=In ''{2}'', moved field ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring.accessed_field=Accessed field ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring.moved_method=In ''{2}'', moved method ''{0}'' will not be visible from ''{2}''
MoveMembersRefactoring.accessed_method=Accessed method ''{0}'' will not be visible from ''{1}''
MoveMembersRefactoring.moved_type=In ''{2}'', moved type ''{0}'' will not be visible from ''{2}''
MoveMembersRefactoring.accessed_type=Accessed type ''{0}'' will not be visible from ''{1}''

MoveRefactoring.scanning_qualified_names=Scanning for qualified names in non C files...

QualifiedNameFinder.update_name=Update fully qualified name

#######################################
# org.eclipse.jdt.internal.core.refactoring.surround
#######################################

SurroundWithTryCatchRefactoring.name=Surround with try/catch Block
SurroundWithTryCatchAnalyzer.doesNotCover=Selection does not cover a set of statements. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
SurroundWithTryCatchAnalyzer.doesNotContain=Selection does not contain statements from a method body or static initializer.
SurroundWithTryCatchAnalyzer.noUncaughtExceptions=No uncaught exceptions are thrown by the selected code.
SurroundWithTryCatchAnalyzer.onlyStatements=Only statements can be surrounded with try/catch blocks.
SurroundWithTryCatchAnalyzer.cannotHandleSuper=Cannot surround a super constructor call.
SurroundWithTryCatchAnalyzer.cannotHandleThis=Cannot surround a constructor invocation.
SurroundWithTryCatchAnalyzer.compile_errors=The selected code cannot be analyzed because of compilation errors. To perform this operation you will need to fix the errors.

#######################################
# org.eclipse.jdt.internal.core.refactoring.util
#######################################

CommentAnalyzer.internal_error=Internal error during precondition checking.
CommentAnalyzer.ends_inside_comment=Selection ends inside a comment.
CommentAnalyzer.starts_inside_comment=Selection starts inside a comment.

StatementAnalyzer.doesNotCover= The selection does not cover a set of statements or an expression. Extend selection to a valid range using the "Expand Selection With" actions from the Edit menu.
StatementAnalyzer.beginning_of_selection=The beginning of the selection contains characters that do not belong to a statement.
StatementAnalyzer.end_of_selection=The end of the selection contains characters that do not belong to a statement.
StatementAnalyzer.do_body_expression=Operation not applicable to a do statement's body and expression.
StatementAnalyzer.for_initializer_expression=Operation not applicable to a for statement's initializer and expression part.
StatementAnalyzer.for_expression_updater=Operation not applicable to a for statement's expression and updater part.
StatementAnalyzer.for_updater_body=Operation not applicable to a for statement's updater and body part.
StatementAnalyzer.catch_argument=Operation is not applicable to a catch block's argument declaration.
StatementAnalyzer.while_expression_body=Operation not applicable to a while statement's expression and body.
StatementAnalyzer.try_statement=Selection must either cover whole try statement or parts of try, catch, or finally block.
StatementAnalyzer.switch_statement=Selection must either cover whole switch statement or parts of a single case block.
StatementAnalyzer.synchronized_statement=Selection must either cover whole synchronized statement or parts of the synchronized block.

CodeAnalyzer.array_initializer=Operation not applicable to an array initializer.
CElementUtil.initializer=initializer

#######################################
# other
#######################################
CopyResourceString.copy=Copy resource ''{0}'' to ''{1}''

RenameAnalyzeUtil.shadows=Problem in ''{0}''. Another name shadows access to the renamed element
CopyRefactoring.update_ref=Update Type Reference
CopyRefactoring.searching=Searching
CompositeChange.performingChangesTask.name=Performing changes...
CodeRefactoringUtil.error.message=The body of the method ''{0}'' cannot be analyzed because of compilation errors in that method. To perform the operation you will need to fix the errors.
InlineTemRefactoring.error.message.nulLiteralsCannotBeInlined=Null literals cannot be inlined
InlineTemRefactoring.error.message.fieldsCannotBeInlined=Cannot inline fields
RenameMethodRefactoring.taskName.checkingPreconditions=Checking preconditions...
RenameMethodRefactoring.taskName.searchingForReferences=Searching for references...

PushDownRefactoring.name=Push Down
PushDownRefactoring.no_subclasses=Class ''{0}'' does not have any modifiable non-anonymous subclasses to which members could be pushed down
PushDownRefactoring.not_in_saved=One of the selected members does not exist in the saved version of the file
PushDownRefactoring.interface_members=Pushing down interface members is not supported
PushDownRefactoring.members_of_binary=Pushing down members declared in binary types is not supported
PushDownRefactoring.members_of_read-only=Pushing down members declared in read-only types is not supported
PushDownRefactoring.calculating=Calculating required members
PushDownRefactoring.referenced=Pushed down member ''{0}'' is referenced by ''{1}''
PushDownRefactoring.checking=Checking referenced elements
PushDownRefactoring.type_not_accessible=Type ''{0}'' referenced in one of the pushed elements is not accessible from type ''{1}''
PushDownRefactoring.field_not_accessible=Field ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PushDownRefactoring.method_not_accessible=Method ''{0}'' referenced in one of the pulled elements is not accessible from type ''{1}''
PushDownRefactoring.gets_instantiated=Class ''{0}'' cannot be made abstract because it gets instantiated
PushDownRefactoring.preview=Creating preview...
PushDownRefactoring.initializer=initializer
PushDownRefactoring.creating_preview=Creating preview...

ChangeSignatureRefactoring.invalid_return_type=''{0}'' is not a valid return type name
ChangeSignatureRefactoring.default_value=Enter the default value for parameter ''{0}''
ChangeSignatureRefactoring.invalid_expression=''{0}'' is not a valid expression
ChangeSignatureRefactoring.parameter_type=Enter the type for parameter ''{0}''
ChangeSignatureRefactoring.invalid_type_name=''{0}'' is not a valid parameter type name
ChangeSignatureRefactoring.unchanged=Method signature and return type are unchanged.
ChangeSignatureRefactoring.parameter_used=Parameter ''{0}'' is used in method ''{1}'' declared in type ''{2}''
ChangeSignatureRefactoring.anonymous_subclass=anonymous subclass of ''{0}''
ChangeSignatureRefactoring.non-virtual=Changing visibility to \'private\' will make this method non-virtual, which may affect the program\'s behavior
ChangeSignatureRefactoring.already_has=Method ''{0}'' already has a parameter named ''{1}''
ChangeSignatureRefactoring.preview=Preparing preview
ChangeSignatureRefactoring.modify_parameters=Modify parameters
ChangeSignatureRefactoring.not_unique=Parameter type name ''{0}'' cannot be uniquely resolved or is not a valid type name.
ChangeSignatureRefactoring.ambiguous=Parameter type name ''{0}'' is ambiguous. There are {1} types with that name.

MoveInnerToTopRefactoring.names_start_lowercase=This name is discouraged. According to convention, names of instance fields and local variables start with lowercase letters.
MoveInnerToTopRefactoring.already_declared=A field named ''{0}'' is already declared in type ''{1}'' 
MoveInnerToTopRefactoring.deleted=The selected type has been deleted from ''{0}''
MoveInnerToTopRefactoring.compilation_Unit_exists=Compilation Unit named ''{0}'' already exists in package ''{1}''
MoveInnerToTopRefactoring.name_used=Name ''{0}'' is used as a parameter name in one of the constructors of type ''{1}'' 
MoveInnerToTopRefactoring.name=Move Member Type to New File
MoveInnerToTopRefactoring.creating_preview=Creating change
MoveInnerToTopRefactoring.move_to_Top=Move Member Type to New File
MoveInnerToTopRefactoring.type_exists=Type named ''{0}'' already exists in package ''{1}''

InstanceMethodMover.move_method=Move instance method
InstanceMethodMover.replace_with_delegation=Replace method body with delegation.
InstanceMethodMover.create_in_receiver=Create method in new receiver\'s class.
InstanceMethodMover.add_imports=Add needed imports for created method
InstanceMethodMover.to_local_localunsupported=Moving to within local classes is currently unsupported.
InstanceMethodMover.parameter_name_used=Parameter name ''{0}'' is already used
InstanceMethodMover.no_static_methods=This refactoring cannot be used to move static methods.
InstanceMethodMover.single_implementation=Select a single method implementation to move.
InstanceMethodMover.no_native_methods=This refactoring cannot be used to move native methods.
InstanceMethodMover.no_synchronized_methods=This refactoring cannot be used to move synchronized methods.
InstanceMethodMover.no_constructors=This refactoring cannot be used to move a constructor.
InstanceMethodMover.uses_super=The method cannot be moved, since it uses the \"super\" keyword.
InstanceMethodMover.refers_enclosing_instances=The method cannot be moved, since it refers to enclosing instances (i.e. <EnclosingClassName>.this).
InstanceMethodMover.potentially_recursive=This refactoring cannot be used to move potentially recursive methods.
InstanceMethodMover.cannot_be_moved=This method cannot be moved, since no possible new receivers were found. An instance method can be moved to source classes that are used as types of its parameters or types of fields declared in the same class as the method.

ExtractInterfaceUtil.update_reference=Update type reference
ExtractInterfaceUtil.update_imports=Update imports

ExtractInterfaceRefactoring.deleted=The selected type has been deleted from ''{0}''
ExtractInterfaceRefactoring.no_Throwable=Extract Interface refactoring is not available on \"java.lang.Throwable\" and its subclasses.
ExtractInterfaceRefactoring.type_exists=Type named ''{0}'' already exists in package ''{1}''
ExtractInterfaceRefactoring.compilation_Unit_exists=Compilation Unit named ''{0}'' already exists in package ''{1}''
ExtractInterfaceRefactoring.internal_Error=Internal Error. Please see log for details.
ExtractInterfaceRefactoring.name=Extract Interface
ExtractInterfaceRefactoring.analyzing...=Analyzing...
ExtractInterfaceRefactoring.update_reference=Update type reference
ExtractInterfaceRefactoring.update_type_declaration=Update type declaration

UseSupertypeWherePossibleRefactoring.deleted=The selected type has been deleted from ''{0}''
UseSupertypeWherePossibleRefactoring.unavailable_on_Throwable=Use Supertype Where Possible refactoring is not available on \"java.lang.Throwable\" and its subclasses.
UseSupertypeWherePossibleRefactoring.name=Use Supertype Where Possible
UseSupertypeWherePossibleRefactoring.analyzing...=Analyzing...

MoveInstanceMethodRefactoring.method_declaration=A method declaration must be selected in order to activate this refactoring.
MoveInstanceMethodRefactoring.name=Move Instance Method

CopyPackageFragmentRootChange.copy=Copy Package Fragment Root ''{0}'' to project ''{1}''

DeletePackageFragmentRootChange.delete=Delete package fragment root ''{0}''

MovePackageFragmentRootChange.move=Move Package Fragment Root ''{0}'' to project ''{1}''

PromoteTempToFieldRefactoring.name=Promote Local Variable to Field
PromoteTempToFieldRefactoring.select_declaration=Select a declaration or a reference to a local variable.
PromoteTempToFieldRefactoring.only_declared_in_methods=Currently, only local variables declared in methods can be converted to fields.
PromoteTempToFieldRefactoring.method_parameters=Cannot convert method parameters to fields.
PromoteTempToFieldRefactoring.exceptions=Cannot convert exceptions declared in catch clauses to fields.
PromoteTempToFieldRefactoring.uses_types_declared_locally=Cannot promote this local variable to a field because it uses types or variables declared locally in the method.
PromoteTempToFieldRefactoring.cannot_promote=Cannot promote this local variable to a field.
PromoteTempToFieldRefactoring.uses_type_declared_locally=Cannot promote this local variable to a field because it uses a type declared locally in the method.
PromoteTempToFieldRefactoring.Name_conflict=Name conflict with name ''{0}'' used in ''{1}''
PromoteTempToFieldRefactoring.Name_conflict_with_field=Name conflict with existing field
PromoteTempToFieldRefactoring.editName=Promote local variable to field

ConvertAnonymousToNestedRefactoring.name=Convert Anonymous to Inner
ConvertAnonymousToNestedRefactoring.place_caret=Place the caret inside an anonymous inner class.
ConvertAnonymousToNestedRefactoring.type_exists=Nested type with that name already exists.
ConvertAnonymousToNestedRefactoring.another_name=Choose another name.
ConvertAnonymousToNestedRefactoring.name_hides=Class name hides an enclosing type name.
ConvertAnonymousToNestedRefactoring.edit_name=Convert anonymous inner class to a nested class

InlineConstantRefactoring.members_declared_in_anonymous=Cannot inline since the initializer to be inlined refers to members declared in an anonymous class scope (currently unsupported).
InlineConstantRefactoring.Inline=Inline Constant
InlineConstantRefactoring.syntax_errors=This file contains syntax errors. To perform this operation you will need to fix the errors.
InlineConstantRefactoring.local_anonymous_unsupported=Inlining of constants defined in local or anonymous classes is currently not supported.
InlineConstantRefactoring.static_final_field=A static final field must be selected.
InlineConstantRefactoring.blank_finals=Inline Constant cannot inline blank finals.
InlineConstantRefactoring.binary_file=Cannot inline this constant, since it is declared in a binary file.
InlineConstantRefactoring.preview=Generating preview ...
InlineConstantRefactoring.inline=Inline Constant
InlineConstantRefactoring.remove_declaration=Remove constant declaration
InlineConstantRefactoring.name=Inline Constant
InlineConstantRefactoring.source_code_unavailable=References in ''{0}'' cannot be inlined since source code is not available

DeleteFileChange.1=Delete file ''{0}''

DeleteFolderChange.0=Delete folder ''{0}''

DeleteSourceManipulationChange.0=Delete ''{0}''
DeleteSourceManipulationChange.1=(default package)

CopyRefactoring.0=Copy

MoveRefactoring.0=Move

OverwriteHelper.0=Confirm overwritting
OverwriteHelper.1=''{0}'' exists in the selected destination. Do you want to overwrite?

ReadOnlyResourceFinder.0=Confirm Delete of Read Only Elements
ReadOnlyResourceFinder.1=The selected elements contain read-only resources. Do you still want to delete them?
ReadOnlyResourceFinder.2=Confirm Move of Read Only Elements
ReadOnlyResourceFinder.3=The selected elements contain read-only resources. Do you still want to move them?

ChangeSignatureRefactoring.new_parameter=Enter the type for the new parameter

MoveInnerToTopRefactoring.29=Creating preview
MoveInnerToTopRefactoring.30=convert nested type to top level
MoveInstanceMethodRefactoring.2=The selected method cannot be moved

PullUpRefactoring.42=Pull up

PushDownRefactoring.25=Push down

ReorgPolicyFactory.doesnotexist0=The selected element cannot be the destination of this operation
ReorgPolicyFactory.readonly=The selected destination is read-only
ReorgPolicyFactory.structure=The structure of the selected destination is not known
ReorgPolicyFactory.inconsistent=The selected destination is not consistent with its underlying resource or buffer
ReorgPolicyFactory.archive=The selected destination is an archive
ReorgPolicyFactory.external=The selected destination is external to the workbench
ReorgPolicyFactory.subCu=Elements inside translation units cannot be used as destinations for copying files, folders or translation units
ReorgPolicyFactory.phantom=The selected destination does not exist or is a phantom resource
ReorgPolicyFactory.inaccessible=The selected destination is not accessible
ReorgPolicyFactory.not_this_resource=The selected resource cannot be used as a destination
ReorgPolicyFactory.linked=Linked resources can only be copied to projects
ReorgPolicyFactory.no_resource=A resource cannot be the destination for the selected elements.
ReorgPolicyFactory.copy=Copy
ReorgPolicyFactory.doesnotexist1=The selected element cannot be the destination for this operation
ReorgPolicyFactory.cannot_modify=The selected destination element cannot be modified
ReorgPolicyFactory.cannot=The selected element cannot be the destination for this operation
ReorgPolicyFactory.package_decl=Package declarations are not available as destinations
ReorgPolicyFactory.src2proj=Source folders can only be copied to C projects
ReorgPolicyFactory.jmodel=The C Model cannot be the destination of this operation
ReorgPolicyFactory.src2writable=Source folders cannot be copied to read-only elements
ReorgPolicyFactory.src2nosrc=Source folders cannot be copied or moved to projects that contain no source folders
ReorgPolicyFactory.packages=Packages can only be moved or copied to source folders or C projects that do not have source folders
ReorgPolicyFactory.cannot1=The selected element cannot be the destination of this operation
ReorgPolicyFactory.noCopying=Copying is not available
ReorgPolicyFactory.element2parent=Elements cannot be moved to their own parents.
ReorgPolicyFactory.package2parent=A package cannot be moved to its own parent.
ReorgPolicyFactory.parent=A file or folder cannot be moved to its own parent.
ReorgPolicyFactory.noMoving=Moving is not available

ReorgUtils.0=file ''{0}''
ReorgUtils.1=folder ''{0}''
ReorgUtils.2=project ''{0}''
ReorgUtils.3=class file ''{0}''
ReorgUtils.4=file ''{0}''
ReorgUtils.5=field ''{0}''
ReorgUtils.6=the import container
ReorgUtils.7=import declaration ''{0}''
ReorgUtils.8=the initializer
ReorgUtils.9=C project ''{0}''
ReorgUtils.10=constructor ''{0}''
ReorgUtils.11=method ''{0}''
ReorgUtils.12=package declaration ''{0}''
ReorgUtils.13=the default package
ReorgUtils.14=package ''{0}''
ReorgUtils.15=source folder ''{0}''
ReorgUtils.16=class folder ''{0}''
ReorgUtils.17=package fragment root ''{0}''
ReorgUtils.18=type ''{0}''
ReorgUtils.19=new {0}() '{...'}
ReorgUtils.20=anonymous type ''{0}''
DeleteChangeCreator.1=Delete elements
DeleteRefactoring.1=Analyzing...
DeleteRefactoring.2=Confirm Referenced Archive Delete
DeleteRefactoring.3=Archive file ''{0}'' is referenced by the following project(s). Do you still want to delete it?
DeleteRefactoring.4=Confirm Folder Delete
DeleteRefactoring.5=Folder ''{0}'' contains a C source folder. Deleting it will delete the source folder as well. Do you still wish to delete it?
DeleteRefactoring.7=Delete
DeleteRefactoring.8=Confirm Delete of Getters/Setters
DeleteRefactoring.9=Do you also want to delete getter/setter methods for field ''{0}''?
MoveStaticMemberAnalyzer.nonStatic=Replacing non-static access to static member with static access

#
# Introduce Factory
IntroduceFactory.name=Introduce Factory
IntroduceFactory.checkingActivation=Checking activation of IntroduceFactory
IntroduceFactory.syntax_error=Introduce Factory cannot be performed due to syntax errors.
IntroduceFactory.checking_preconditions=Checking preconditions for Introduce Factory...
IntroduceFactory.examiningSelection=Examining selection...
IntroduceFactory.notAConstructorInvocation=Selected entity is not a constructor invocation or definition.
#
IntroduceFactory.noASTNodeForConstructorSearchHit=Can\'t find AST node for constructor search hit @ [''{0}'', ''{1}'']: <''{2}''> in translation unit ''{3}''
IntroduceFactory.unexpectedInitializerNodeType=Unexpected AST node type for initializer when searching for constructor call: \'''{0}''\' in translation unit ''{1}''
IntroduceFactory.noConstructorCallNodeInsideFoundVarbleDecl=Couldn\'t find AST node for constructor call inside ''{0}''
IntroduceFactory.unexpectedASTNodeTypeForConstructorSearchHit=Unexpected AST node type for constructor search hit: ''{0}'' in translation unit ''{1}''
IntroduceFactory.noBindingForSelectedConstructor=Couldn\'t resolve binding of selected constructor; perhaps a reference to an unknown type.
#
IntroduceFactory.addFactoryMethod=Add factory method
IntroduceFactory.replaceCalls=Replace constructor calls with calls to factory method
IntroduceFactory.protectConstructor=Protect constructor
#
IntroduceFactory.unsupportedNestedTypes=Introduce Factory does not support constructors on nested types.
IntroduceFactory.duplicateMethodName=Duplicate method name: 
IntroduceFactory.createChanges=Creating changes for IntroduceFactory
IntroduceFactory.topLevelChangeLabel=Changes to introduce factory for 
IntroduceFactory.constructorInBinaryClass=Introduce Factory is not supported when the constructor is in a binary class.
IntroduceFactory.unableToResolveConstructorBinding=Unable to resolve call target; perhaps there are compilation errors?
IntroduceFactory.callSitesInBinaryClass=Constructor call sites in binary classes can not be replaced by factory method calls.
#
# Generalize Type
ChangeTypeRefactoring.Generalize_Type=Generalize Type
ChangeTypeRefactoring.checking_preconditions=Checking preconditions...
ChangeTypeRefactoring.changes=Computing changes
ChangeTypeRefactoring.name=Generalize Type
ChangeTypeRefactoring.cantDoIt=Type of selected declaration cannot be changed
ChangeTypeRefactoring.notSupportedOnNodeType=Generalize Type is only supported on declarations of variables, parameters, and fields, and on method return types.
ChangeTypeRefactoring.notSupportedOnBinary=Generalize Type is not allowed on return types and parameters of methods that override binary methods.
ChangeTypeRefactoring.invalidSelection=Invalid selection for Generalize Type.
ChangeTypeRefactoring.multiDeclarationsNotSupported=Multi-declarations currently not handled.
ChangeTypeRefactoring.noMatchingConstraintVariable=No constraint variable matches the selected ASTNode.
ChangeTypeRefactoring.unhandledSearchException=exception occurred during search: 
ChangeTypeRefactoring.failedToSelectType=failed to select type: 
ChangeTypeMessages.CreateChangesForChangeType=Creating changes for Generalize Type...
ChangeTypeRefactoring.javaLangObject=java.lang.Object
ChangeTypeRefactoring.arraysNotSupported=Generalize Type is currently not supported on array types.
ChangeTypeRefactoring.localTypesNotSupported=Generalize Type is currently not supported on local types.
ChangeTypeRefactoring.primitivesNotSupported=Generalize Type is not supported on primitive types.
ChangeTypeRefactoring.typeChange=change declared type from 
ChangeTypeRefactoring.allChanges=All changes needed for Generalize Type
ChangeTypeRefactoring.to=\ to 
ChangeTypeRefactoring.analyzingMessage=Analyzing...
