% Parsing and Program Analysis

\textit{Last Updated 10/2/07}

\section{The Virtual Program Graph}

In Photran, it is almost never necessary to call the lexer, parser, or analysis components directly.  Instead, it
uses a \textit{virtual program graph} (VPG), which provides the fa\,cade of a whole-program abstract syntax tree with
embedded analysis information.

An overview of VPGs is available at the following link and will not repeated here:

http://jeff.over.bz/software/vpg/doc/

\section{Using the Photran VPG}

\subsection{Acquiring and Releasing Translation Units}

\texttt{PhotranVPG} is a singleton object responsible for constructing
ASTs for Fortran source code.  ASTs are retrieved by invoking either
{\footnotesize\begin{verbatim}
    public IFortranAST acquireTransientAST(IFile file)
\end{verbatim}}
or
{\footnotesize\begin{verbatim}
	public IFortranAST acquirePermanentAST(IFile file)
\end{verbatim}}

A \textit{transient AST} can be garbage collected as soon as references to any
of its nodes disappear.  A \textit{permanent AST} will be explicitly kept in
memory until a call is made to either
{\footnotesize\begin{verbatim}
	public void releaseAST(IFile file)
\end{verbatim}}
or
{\footnotesize\begin{verbatim}
	public void releaseAllASTs()
\end{verbatim}}

Only one AST for a particular file is in memory at any particular point in time,
so successive requests for the same
\texttt{IFile} will return the same (pointer-identical) AST
until the AST is released (permanent) or garbage collected (transient).

\subsection{The Program Representation: IFortranAST}

The \texttt{acquireTransient/PermanentAST} methods return an object implementing \texttt{IFortranAST}.

\lstset{language=Java}

\begin{lstlisting}
public interface IFortranAST extends Iterable<Token>
{
    ///////////////////////////////////////////////////////////////////////////
    // Visitor Support
    ///////////////////////////////////////////////////////////////////////////

    public void visitTopDownUsing(ASTVisitor visitor);
    public void visitBottomUpUsing(ASTVisitor visitor);
    public void visitOnlyThisNodeUsing(ASTVisitor visitor);
    public void visitUsing(GenericParseTreeVisitor visitor);
    
    ///////////////////////////////////////////////////////////////////////////
    // Other Methods
    ///////////////////////////////////////////////////////////////////////////

    public ASTExecutableProgramNode getRoot();

    public Iterator<Token> iterator();
    public Token findTokenByStreamOffsetLength(int offset, int length);
    public Token findFirstTokenOnLine(int line);
    public Token findTokenByFileOffsetLength(IFile file, int offset, int length);
}
\end{lstlisting}

The \texttt{getRoot} method returns the root of the AST, while the \texttt{find...}
methods provide an efficient means to search for tokens based on their lexical
positioning.

\subsection{AST Structure}

The Fortran AST comprises several hundred classes.  The class names of AST nodes all begin with
\texttt{AST}, and all are located in the \texttt{org.eclipse.photran.internal.core.parser} package.
The AST classes are generated automatically from the parsing grammar,
\texttt{fortran95.bnf}.

\subsubsection{Ordinary AST Nodes}

The children of any AST node are retrieved by calling one of its \texttt{get...}
methods, which return \texttt{null} if that child is not present.
For example, \texttt{fortran95.bnf} defines a \textit{$<$ProgramUnit$>$} as follows.

{\footnotesize\begin{verbatim}
# R202
<ProgramUnit> ::=
    <MainProgram>
  | <FunctionSubprogram>
  | <SubroutineSubprogram>
  | <Module>
  | <BlockDataSubprogram>
\end{verbatim}}

An \texttt{ASTProgramUnitNode} object, then, provides the following interface.

\begin{lstlisting}
public class ASTProgramUnitNode extends ParseTreeNode
{
    public ASTMainProgramNode getASTMainProgram() { ... }
    public ASTFunctionSubprogramNode getASTFunctionSubprogram() { ... }
    public ASTSubroutineSubprogramNode getASTSubroutineSubprogram() { ... }
    public ASTModuleNode getASTModule() { ... }
    public ASTBlockDataSubprogramNode getASTBlockDataSubprogram() { ... }
}
\end{lstlisting}

\subsubsection{List Nodes (Recursive Productions)}

Recursive productions are treated specially, since they are used frequently to
express lists in the grammar.  The recursive member is labeled in the grammar
with an @ symbol.  For example,

{\footnotesize\begin{verbatim}
<Body> ::=
    <BodyConstruct>
  | @:<Body> <BodyConstruct>
\end{verbatim}}

indicates that a \textit{$<$Body$>$} consists of several \textit{$<$BodyConstruct$>$}s.
They can be iterated with code such as the following.

{\footnotesize\begin{verbatim}
for (int i = 0, size = astBodyNode.size(); i < size; i++)
    doSomething(astBodyNode.getASTBodyConstruct(i);
\end{verbatim}}

\subsubsection{Elevated Nodes}

Consider the following productions for a main program in Fortran.

{\footnotesize\begin{verbatim}
<MainProgram> ::=
  |               <MainRange>
  | <ProgramStmt> <MainRange>

<MainRange> ::=
    <Body>              <EndProgramStmt>
  | <BodyPlusInternals> <EndProgramStmt>
  |                     <EndProgramStmt>
\end{verbatim}}

From the standpoint of a typical Fortran user,
a main program consists of a Program statement, a body (list of statements), perhaps some internal
subprograms, and an End Program statement.
This does not match the definition of a MainProgram in the parsing grammar above: the body and End Program
statement are relegated to a separate MainRange nonterminal. 

The solution is to label the MainRange nonterminal with a caret (\^), indicating that it is an ``elevated'' or
``pulled-up'' node.

{\footnotesize\begin{verbatim}
<MainProgram> ::=
  |               ^:<MainRange>
  | <ProgramStmt> ^:<MainRange>

<MainRange> ::=
    <Body>              <EndProgramStmt>
  | <BodyPlusInternals> <EndProgramStmt>
  |                     <EndProgramStmt>
\end{verbatim}}

This means that accessor methods that would otherwise be in a separate MainRange object will be placed in the
MainProgram object instead.  This means that an \texttt{ASTMainProgramNode} object has the following interface.

\begin{lstlisting}[numbers=none]
    public ASTProgramStmtNode getProgramStmt();
    public ASTBodyNode getBody();
    public ASTBodyPlusInternalsNode getBodyPlusInternals();
    public ASTEndProgramStmtNode getEndProgramStmt();
\end{lstlisting}

\subsubsection{Tokens}

\texttt{Token}s form the leaves of the AST.  They record, among other things,
\begin{itemize}
\item The terminal symbol in the grammar that the token is an instance of (\texttt{getTerminal()})
\item The actual text of the token (\texttt{getText()})
\item The line, column, offset, and length of the token text in the source file (\texttt{getLine(), getCol(), getOffset(), getLength()})
\end{itemize}
Most of the remaining fields are used internally for refactoring.

\section{Scope and Binding Analysis}

Certain nodes in a Fortran AST represent a lexical scope.  All of these are declared as subclasses of
\texttt{ScopingNode.}
\begin{itemize}
\item ASTBlockDataSubprogramNode
\item ASTDerivedTypeDefNode
\item ASTExecutableProgramNode
\item ASTFunctionSubprogramNode
\item ASTInterfaceBlockNode\footnote{An interface block defines a nested scope only if it is a named interface.
                                     Anonymous (unnamed) interfaces provide signatures for subprograms in their
                                     enclosing scope.}
\item ASTMainProgramNode
\item ASTModuleNode
\item ASTSubroutineSubprogramNode
\end{itemize}

The enclosing scope of a \texttt{Token} can be retrieved by calling the following method on the \texttt{Token} object.
 
{\footnotesize\begin{verbatim}
    public ScopingNode getEnclosingScope()
\end{verbatim}}

Identifier tokens (\texttt{Token}s for which \texttt{token.getTerminal() == Terminal.T\_IDENT}),
which represent functions, variables, etc. in the Fortran grammar, are \emph{bound} to a declaration.
(The introduction to VPGs (URL above) provides an example visually.)  Although, ideally, every identifier
will be bound to exactly one declaration, this is not always the case (the programmer may have written incorrect code,
or Photran may not have enough information to resolve the binding uniquely).  So the \texttt{resolveBinding} method
on a token has the following signature: 

{\footnotesize\begin{verbatim}
    public List<Definition> resolveBinding()
\end{verbatim}}

The \texttt{Definition} object contains information about what type of entity was defined (local variable, function,
common block, etc.), array information (if applicable), whether it was defined implicitly, etc.

\section{Type Checking}

The type of any expression (\texttt{ASTExprNode}) can be determined by invoking the static method
\texttt{TypeChecker.getTypeOf(node)}.  At the time of writing, this behavior is not completely implemented.



\section{How to Get Acquainted with the Program Representation}

\subsection{Visualizing ASTs}

Photran can display ASTs rather than the ordinary Outline view.
This behavior can be enabled from the Fortran workspace preferences
(click on Window $>$ Preferences in Windows/Linux, or
Eclipse $>$ Preferences in Mac OS X).  Clicking on an AST node in the Outline
view will move the cursor to that construct's position in the source file.

\subsection{Visually Resolving Bindings}

In a Fortran editor, click on an identifier (positioning the cursor over it),
and press F3 (or click Navigate $>$ Open Declaration, or right-click and choose Open Declaration.)  The
binding will be resolved and the declaration highlighted.  If there are multiple bindings, a popup window will open
and one can be selected.  If the identifier is bound to a declaration in a module defined in a different file, an
editor will be opened on that file.

\subsection{Visualizing Enclosing Scopes}

Click on any token in the Fortran editor, and click Refactor $>$ (Debugging) $>$ Select Enclosing Scope.
The entire range of source text for that token's enclosing \texttt{ScopingNode} will be highlighted.

\subsection{Visualizing Definitions}

Open a file in the Fortran editor, and
click Refactor $>$ (Debugging) $>$ Display Symbol Table for Current File.
Indentation shows scope nesting, and each line summarizes the information in a \texttt{Definition} object.
