% Refactoring

\textit{Last Updated 10/2/07}

\section{Structure of a Refactoring}

Refactorings in Photran are subclassed from \texttt{FortranRefactoring},
which is in turn a subclass of the \texttt{Refactoring} class provided
by the Eclipse Language ToolKit (LTK).

Refactorings must
implement three methods:

{\footnotesize\begin{verbatim}
    public String getName();
    protected abstract void doCheckInitialConditions(RefactoringStatus status, IProgressMonitor pm) throws PreconditionFailure;
    protected abstract void doCheckFinalConditions(RefactoringStatus status, IProgressMonitor pm) throws PreconditionFailure;
    protected abstract void doCreateChange(IProgressMonitor pm) throws CoreException, OperationCanceledException;
\end{verbatim}}

\texttt{getName} simply returns the name of the refactoring: ``Rename,'' ``Extract Subroutine,''
``Introduce Implicit None,'' or something similar.

Initial conditions are checked before any dialog is displayed to the user.
An example would be making sure that the user has selected an identifier to rename.
If the check fails, a \texttt{PreconditionFailure} should be thrown with a message
describing the problem for the user.

Final conditions are checked after the user has provided any input.
An example would be making sure that a string is a legal identifier.

The actual transformation is done in the \texttt{doCreateChange} method,
which will be called only after the final preconditions are checked.

The \texttt{FortranRefactoring} class provides a large number of \texttt{protected} utility methods common among
refactorings, such as a method to determine if a token is a uniquely-bound identifier, a method to parse fragments
of code that are not complete programs, and a \texttt{fail} method which is simply shorthand for throwing a 
\texttt{PreconditionFailure}.

\section{AST Rewriting}

After it is determined what files are affected by a refactoring, manipulating the source code
in the \texttt{doCreateChange} method is conceptually straightforward.
\begin{enumerate}
\item To change the text of a single token, simply call its \texttt{setText} method.
\item To remove part of an AST, call the static method \texttt{SourceEditor.cut(node)}, which will remove
      the given node (and all of its children), returning it.
\item To insert a node into an ast, call one of the \texttt{SourceEditor.paste...} methods.  The pasted node
      will be automatically reindented to match its surroundings.
\item To insert new nodes (e.g., hard-coded statements) into an AST, call one of the \texttt{parseLiteral...}
      methods inherited from the \texttt{FortranRefactoring} class to construct an AST fragment for the node, and
      then use \texttt{SourceEditor.paste...} to paste it at the appropriate position in the AST.
\end{enumerate}

After all of the changes have been made to a file's AST,
\texttt{addChangeFromModifiedAST(IFile file)} should be invoked to
commit the change, after which it is safe to call \texttt{FortranWorkspace.getInstance().release...}.

\textbf{CAUTION:} Internally, the AST is changed only enough to reproduce correct source code.  After making changes
to an AST, most of the accessor methods on \texttt{Token}s (\texttt{getLine(), getOffset(),} etc.)
will return \textit{incorrect} values.  This also means that the \texttt{find...} methods in \texttt{IFortranAST}
will not work, and binding information will be incorrect.  Due to the complex internal structure of the AST, accessor
methods on AST nodes cannot be called either.  Therefore, \textit{all program analysis should be done first;}
pointers to all relevant nodes and tokens should be obtained \textit{prior to} making any modifications to the AST.
In other words, it is best to consider the AST ``write-only'' as soon as any change has been made.

\section{User Interface}

Adding a refactoring to the user interface is best done by following an example.
First, an action must be added to both the editor popup menu \textit{and} the Refactor
menu in the menu bar by modifying the plugin.xml file in the org.eclipse.photran.refactoring.ui plug-in.
Then, the action delegate must be created to populate the user interface of the refactoring wizard dialog;
\texttt{RenameAction} (in the \texttt{org.eclipse.photran.internal.refactoring.ui} package)
can be used as a starting point.

\section{Examples: Rename and Introduce Implicit None}

The Rename refactoring (\texttt{org.eclipse.photran.internal.core.refactoring.RenameRefactoring})
and the Introduce Implicit None refactoring
(\texttt{org.eclipse.photran.internal.core.refactoring.IntroImplicitNoneRefactoring})
are non-trivial but readable and should serve as a model for building future Fortran refactorings.
