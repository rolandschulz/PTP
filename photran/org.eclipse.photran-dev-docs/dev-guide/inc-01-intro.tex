% Introduction

Photran is a IDE for Fortran 90/95 and Fortran 77 that is built on top of
Eclipse.  It is structured as an Eclipse feature, in other words,
as a set of plug-ins that are designed to be used together.
Starting with version 3.0, it is an extension of CDT, the Eclipse IDE for
C/C++.  Previous versions of Photran were created by hacking a copy of the
CDT to support Fortran instead of C/C++, but now we have developed a
mechanism for adding new languages into the CDT, allowing the Fortran support
code to be in its own set of plug-ins.

Our purpose in writing Photran was to create a refactoring tool for Fortran.
Thus, Photran has a complete parser and program representation.  Photran
adds a Fortran editor and several preference pages to the CDT user interface,
as well as a Fortran Managed Make project type.

This document explains the design of Photran so that you could fix a bug or
add a refactoring.  You should know how to use Photran and how
the CDT works.  You need to understand Eclipse and Eclipse plug-ins
before you read this document.  We recommend \textit{The Java
Developer's Guide to Eclipse} for Eclipse newcomers.

\section{CDT Terminology}

The following are CDT terms that will be used extensively when discussing
Photran.

\begin{itemize}

\item \textbf{Standard Make projects} are ordinary Eclipse projects, except that
the CDT (and Photran) recognize them as being ``their'' type of project
(as opposed to, say, projects for JDT, EMF, or another Eclipse-based tool).
The user must supply their own Makefile, typically with targets ``clean''
and ``all.''  CDT/Photran cleans and builds the project by running
\texttt{make}.

\item \textbf{Managed Make projects} are similar to standard make projects,
except that CDT/Photran automatically generates a Makefile and edits
the Makefile automatically when source files are added to or removed
from the project.  The \textbf{Managed Build System} is the part of
CDT and Photran that handles all of this.

\item \textbf{Binary parsers} are able to detect whether a file is a legal
executable for a platform (and extract other information from it).
The CDT provides binary parsers for
Windows (PE), Linux (ELF), Mac OS X (Mach), and others.  Photran
does not provide any additional binary parsers.

\item \textbf{Error parsers} are provided for many compilers.  CDT provides
a gcc error parser, for example.  Photran provides error parsers for
Lahey Fortran, F, g95, and others.  Essentially, error parsers scan the
output of \texttt{make} for error messages for their associated compiler.
When they see an error message they can recognize, they extract the
filename, line number, and error message, and use it to populate the
Problems view.

\item CDT keeps a \textbf{model} of all of the files in a project.
The model is essentially a tree of \textbf{elements}, which all
derive from a (CDT Core) class \texttt{ICElement}.  It is described
in the next section.

\end{itemize}

\section{The Model}

The Make Projects view in Photran is essentially a visualization of
the CDT's \textit{model}, a tree data structure describing the contents
of all Make Projects in the workspace as well as the high-level contents
(functions, aggregate types, etc.) of source files.

Alain Magloire (CDT) described the model, A.K.A. the \texttt{ICElement}
hierarchy, in the thread
``Patch to create ICoreModel interface''
on the cdt-dev mailing list:

\begin{verbatim}
So I'll explain a little about the ICElement and what we get
out of it for C/C++.

The ICElement hierarchy can be separated in two:
(1) - how the Model views the world/resources (all classes above ITranslationUnit)
(2) - how the Model views the world/language (all classes below ITranslationUnit).

How we(C/C++) view the resources:
- ICModel  --> [root of the model]
    - ICProject --> [IProject with special attributes/natures]
        - ISourceRoot --> [Folder with a special attribute]
            - ITranslationUnit --> [IFile with special attributes, for example extensions *.c]
            - IBinary --> [IFile with special attributes, elf signature, coff etc...]
            - IArchive --> [IFile with special attributes, "<ar>" signature]
            - ICContainer -> [folder]

There are also some special helper classes
    - ILibraryReference [external files use in linking ex:libsocket.so, libm.a, ...]
    - IIncludeReference [external paths use in preprocessing i.e. /usr/include, ...]
    - IBinaryContainer [virtual containers regrouping all the binaries find in the project]

This model of the resources gives advantages:
- navigation of the binaries,
- navigation of the include files not part of the workspace (stdio.h, socket.h, etc ...)
- adding breakpoints
- search
- contribution on the objects
etc.....

[...]

(2) How we view the language.

Lets be clear this is only a simple/partial/incomplete view of the language.
For example, we do not drill down in blocks, there are no statements(if/else conditions) etc ....
For a complete interface/view of the language, clients should use the __AST__ interface.
\end{verbatim}

From another one of Alain's posts in that thread:

\begin{verbatim}
Lets make sure we are on the same length about the ICElement hierarchy.
It was created for a few reasons:

- To provide a simpler layer to the AST.  The AST interface is too complex
  to handle in most UI tasks.
- To provide objects for UI contributions/actions.
- The glue for the Working copies in the Editor(CEditor), IWorkingCopy class
- The interface for changed events.
- ...

Basically it was created for the UI needs: Outliner, Object action contributions,
C/C++ Project view and more.

The CoreModel uses information taken from:
- the Binary Parser(Elf, Coff, ..)
- the source Parser(AST parser)
- the IPathEntry classes
- the workspace resource tree
- The ResolverModel (*.c, *.cc extensions), ...

to build the hierarchy.
\end{verbatim}

\section{The CDT Debugger and \texttt{gdb}}

\begin{itemize}

\item The so-called CDT debugger is actually just a graphical interface to
\texttt{gdb}, or more specifically to \texttt{gdb/mi}.  If something
doesn't work, try it in \texttt{gdb} directly, or using another
\texttt{gdb}-based tool such as DDD.

\item The debugger UI ``contributes'' breakpoint markers and actions
to the editor.  The ``set breakpoint'' action, and the breakpoint markers
that appear in the ruler of the CDT (and Photran) editors are handled
entirely by the debug UI: You will \textit{not} find code for them in the
Photran UI plug-in.

\item \texttt{gdb} reads debug symbols from the executable it is debugging.
That is how it knows what line it's on, what file to open, etc.  Photran
has \textit{nothing} to do with this: These symbols are written entirely
by the compiler.  Moreover, the compiler determines what shows up in the
Variables view.  If the debugger views seem to be a mess, it is the
compiler's fault, not Photran's.

\end{itemize}
