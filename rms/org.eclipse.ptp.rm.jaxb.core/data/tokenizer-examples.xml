<?xml version="1.0" encoding="UTF-8"?>
<resource-manager-data name="test-parser-rm">
	<control>
		<parsers>
			<!-- EXAMPLE 1: output is a list of line-separated queue names to be assigned
				to the known property "available-queues" -->
			<stream-parser name="1" stderr="false">
				<tokenizer>
					<read delim="\n">
						<match>
							<regex>.*</regex>
							<target ref="available_queues"/>
							<append field="value" separator="," groups="0"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 2: output is to be searched for its final line which should
				contain a job id of the form "[digits].[chars]" -->
			<stream-parser name="2" stderr="false">
				<tokenizer>
					<read delim="\n" all="true" save="1">
						<match>
							<regex>([\d]*)[.].*</regex>
							<target ref="jobId"/>
							<set field="value" group="1"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 3: indeterminate number and order of lines containing parts
				of attribute definitions, but each line bearing a distinct
				id (e.g., openMPI attribute discovery) -->
			<stream-parser name="3" stderr="false">
				<tokenizer>
					<read delim="\n">
						<match>
							<regex>mca:.*:param:([^:]*):value:(.*)</regex>
							<target type="attribute" idFrom="1"/>
							<set field="name" group="1"/>
							<set field="visible" value="true"/>
							<set field="value" group="2"/>
						</match>
						<match>
							<regex>mca:.*:param:([^:]*):status:(.*)</regex>
							<target type="attribute" idFrom="1"/>
							<set field="status" group="2"/>
							<test set="readOnly" op="EQ">
							  <value>this.status</value>
							  <value>read-only</value>
							</test>
						</match>
						<match>
							<regex>mca:.*:param:([^:]*):help:(.*)</regex>
							<target type="attribute" idFrom="1"/>
							<set field="tooltip" group="2"/>
						</match>
						<match>
							<regex>(.*):([^:]*)</regex>
							<target type="attribute" idFrom="1"/>
							<set field="name" group="1"/>
							<set field="value" group="2"/>
							<set field="visible" value="false"/>
							<set field="readOnly" value="true"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 4a: indeterminate number of definitions, but grouped
				by delimiter -->
			<stream-parser name="4a" stderr="false">
				<tokenizer>
					<read delim="\n">
						<match>
							<regex>PROPERTY</regex>
						</match>
					</read>
					<read delim="\n" mode="and">
						<match>
							<regex>name:(.*)</regex>
							<target type="property"/>
							<set field="name" group="1"/>
						</match>
						<match>
							<regex>value:(.*)</regex>
							<set field="value" group="1"/>
						</match>
					</read>
					<read delim="\n">
						<match>
							<regex>ATTRIBUTE</regex>
						</match>
					</read>
					<read delim="\n" mode="and">
						<match>
							<regex>name:(.*)</regex>
							<target type="attribute"/>
							<set field="name" group="1"/>
						</match>
						<match>
							<regex>value:(.*)</regex>
							<set field="value" group="1"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 4b: similar to 4a, but without delimiter (implicit ordering) -->
			<stream-parser name="4b" stderr="false">
				<tokenizer>
					<read delim="\n" mode="and">
						<match>
							<regex>.*</regex>
							<target type="attribute"/>
							<set field="name" group="0"/>
						</match>
						<match>
							<regex>.*</regex>
							<set field="type" group="0"/>
						</match>
						<match>
							<regex>.*</regex>
							<set field="description" group="0"/>
						</match>
						<match>
							<regex>.*</regex>
							<set field="tooltip" group="0"/>
						</match>
						<match>
							<regex>.*</regex>
							<set field="value" group="0"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 4c: like 4a, but with indeterminate type order -->
			<stream-parser name="4c" stderr="false">
				<tokenizer>
					<read maxMatchLen="32">
						<match>
							<regex flags="DOTALL">.*PROPERTY.*name:(\w*).*value:([\d.-]*).*</regex>
							<target type="property"/>
							<set field="name" group="1"/>
							<set field="value" group="2"/>
						</match>
						<match>
							<regex flags="DOTALL">.*PROPERTY.*value:([\d.-]*).*name:(\w*).*</regex>
							<target type="property"/>
							<set field="value" group="1"/>
							<set field="name" group="2"/>
						</match>
						<match>
							<regex flags="DOTALL">.*ATTRIBUTE.*name:(\w*).*value:([\d.-]*).*</regex>
							<target type="attribute"/>
							<set field="name" group="1"/>
							<set field="value" group="2"/>
						</match>
						<match>
							<regex flags="DOTALL">.*ATTRIBUTE.*value:([\d.-]*).*name:(\w*).*</regex>
							<target type="attribute"/>
							<set field="value" group="1"/>
							<set field="name" group="2"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 5: indeterminate number of property definitions, but on single line -->
			<stream-parser name="5" stderr="false">
				<tokenizer>
					<read delim="\n">
						<match>
							<regex>&lt;name&gt;(.*)&lt;/name&gt;&lt;value&gt;(.*)&lt;/value&gt;</regex>
							<target type="property"/>
							<set field="name" group="1"/>
							<set field="value" group="2"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
			<!-- EXAMPLE 6: looking for values interspersed in the stream but which will
				not exceed 64chars -->
			<stream-parser name="6" stderr="false">
				<tokenizer>
					<read maxMatchLen="32">
						<match>
							<regex flags="DOTALL">&lt;job&gt;([\d]*):([\w]*)&lt;/job&gt;</regex>
							<target ref="jobStates"/>
							<put field="value" keyGroups="1" valueGroups="2"/>
						</match>
					</read>
				</tokenizer>
			</stream-parser>
		</parsers>
	</control>
	<monitor></monitor>
</resource-manager-data>