<?xml version="1.0" encoding="UTF-8"?>
<resource-manager-builder xmlns="http://org.eclipse.ptp/rm" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="resource_manager_type.xsd" name="test-parsers">
	<control-data>
		<!-- EXAMPLE 1: output is a list of line-separated queue names to be assigned
			to the known property "available-queues" -->
		<start-up-command name="test00ParseQstat">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n">
					<match>
						<expression>[^\s]+</expression>
						<target ref="available_queues"/>
						<append field="value" separator=",">
							<entry valueGroup="0"/>
						</append>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 2: output is to be searched for its final line which should
			contain a job id of the form "[digits].[chars]" -->
		<start-up-command name="test01JobId">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n" all="true" save="1">
					<match>
						<expression>([\d]*)[.].*</expression>
						<target ref="@jobId"/>
						<set field="value">
							<entry valueGroup="1"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 3: indeterminate number and order of lines containing parts
			of attribute definitions, but each line bearing a distinct
			id (e.g., openMPI attribute discovery) -->
		<start-up-command name="test02OpenMPI">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n">
					<match>
						<expression>mca:.*:param:([^:]*):value:(.*)</expression>
						<target type="attribute" idFrom="1"/>
						<set field="name">
							<entry valueGroup="1"/>
						</set>
						<set field="selected">
							<entry value="true"/>
						</set>
						<set field="value">
							<entry valueGroup="2"/>
						</set>
					</match>
					<match>
						<expression>mca:.*:param:([^:]*):status:(.*)</expression>
						<target type="attribute" idFrom="1"/>
						<set field="status">
							<entry valueGroup="2"/>
						</set>
						<test op="EQ">
							<value>this.status</value>
							<value>read-only</value>
							<set field="readOnly">
								<entry value="true"/>
							</set>
							<else>
								<set field="readOnly">
									<entry value="false"/>
								</set>
							</else>
						</test>
					</match>
					<match>
						<expression>mca:.*:param:([^:]*):help:(.*)</expression>
						<target type="attribute" idFrom="1"/>
						<set field="tooltip">
							<entry valueGroup="2"/>
						</set>
					</match>
					<match>
						<expression>(.*):([^:]*)</expression>
						<target type="attribute" idFrom="1"/>
						<set field="name">
							<entry valueGroup="1"/>
						</set>
						<set field="value">
							<entry valueGroup="2"/>
						</set>
						<set field="selected">
							<entry value="false"/>
						</set>
						<set field="readOnly">
							<entry value="true"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 4: indeterminate number of definitions, but grouped
			by delimiter -->
		<start-up-command name="test03ImplicitWithTags">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n">
					<match>
						<expression>PROPERTY</expression>
					</match>
				</read>
				<read delim="\n" mode="and">
					<match>
						<expression>name:(.*)</expression>
						<target type="property" idFrom="1"/>
<!--						<set field="name">-->
<!--							<entry valueGroup="1"/>-->
<!--						</set>-->
					</match>
					<match>
						<expression>value:(.*)</expression>
						<set field="value">
							<entry valueGroup="1"/>
						</set>
					</match>
				</read>
				<read delim="\n">
					<match>
						<expression>ATTRIBUTE</expression>
					</match>
				</read>
				<read delim="\n" mode="and">
					<match>
						<expression>name:(.*)</expression>
						<target type="attribute" idFrom="1"/>
<!--						<set field="name">-->
<!--							<entry valueGroup="1"/>-->
<!--						</set>-->
					</match>
					<match>
						<expression>value:(.*)</expression>
						<set field="value">
							<entry valueGroup="1"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 5: similar to 4, but without delimiter (implicit ordering) -->
		<start-up-command name="test04ImplicitOrdering">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n" mode="and">
					<match>
						<expression>.*</expression>
						<target type="attribute"/>
						<set field="name">
							<entry valueGroup="0"/>
						</set>
					</match>
					<match>
						<expression>.*</expression>
						<set field="type">
							<entry valueGroup="0"/>
						</set>
					</match>
					<match>
						<expression>.*</expression>
						<set field="description">
							<entry valueGroup="0"/>
						</set>
					</match>
					<match>
						<expression>.*</expression>
						<set field="tooltip">
							<entry valueGroup="0"/>
						</set>
					</match>
					<match>
						<expression>.*</expression>
						<set field="value">
							<entry valueGroup="0"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 6: like 4, but with indeterminate type order -->
		<start-up-command name="test05ImplicitWithTagsDotall">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read maxMatchLen="32">
					<match>
						<expression flags="DOTALL">.*PROPERTY.*name:(\w*).*value:([\d.-]*).*</expression>
						<target type="property"/>
						<set field="name">
							<entry valueGroup="1"/>
						</set>
						<set field="value">
							<entry valueGroup="2"/>
						</set>
					</match>
					<match>
						<expression flags="DOTALL">.*PROPERTY.*value:([\d.-]*).*name:(\w*).*</expression>
						<target type="property"/>
						<set field="name">
							<entry valueGroup="2"/>
						</set>
						<set field="value">
							<entry valueGroup="1"/>
						</set>
					</match>
					<match>
						<expression flags="DOTALL">.*ATTRIBUTE.*name:(\w*).*value:([\d.-]*).*</expression>
						<target type="attribute"/>
						<set field="name">
							<entry valueGroup="1"/>
						</set>
						<set field="value">
							<entry valueGroup="2"/>
						</set>
					</match>
					<match>
						<expression flags="DOTALL">.*ATTRIBUTE.*value:([\d.-]*).*name:(\w*).*</expression>
						<target type="attribute"/>
						<set field="name">
							<entry valueGroup="2"/>
						</set>
						<set field="value">
							<entry valueGroup="1"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 7: indeterminate number of property definitions, but on single line -->
		<start-up-command name="test06PropertyDefsSingleLine">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read delim="\n">
					<match>
						<expression expression="&lt;name&gt;(.*)&lt;/name&gt;&lt;value&gt;(.*)&lt;/value&gt;"/>
						<target type="property"/>
						<set field="name">
							<entry valueGroup="1"/>
						</set>
						<set field="value">
							<entry valueGroup="2"/>
						</set>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<!-- EXAMPLE 8: looking for values interspersed in the stream but which will
			not exceed 32 chars -->
		<start-up-command name="test07JobStates">
			<args>
				<arg></arg>
			</args>
			<stdout-parser>
				<read maxMatchLen="32">
					<match>
						<expression flags="DOTALL">.*&lt;job&gt;([\d]*):([\w]*)&lt;/job&gt;.*</expression>
						<target ref="jobStates"/>
						<put field="value">
							<entry keyGroup="1" valueGroup="2"/>
						</put>
					</match>
				</read>
			</stdout-parser>
		</start-up-command>
		<submit-interactive name="empty">
			<args>
				<arg></arg>
			</args>
		</submit-interactive>
		<get-job-status name="test10GetStatus">
			<args>
            <arg>/Users/arossi/qstatId</arg>
            <arg>${rm:@jobId#value}</arg>
         </args>
			<stdout-parser>
				<read delim="\n">
					<match>
						<expression>.+[\s]+.+[\s]+.+[\s]+.+[\s]+([A-Z])[\s]+.+</expression>
						<target ref="@jobId"/>
						<set field="value">
						   <entry valueGroup="1"/>
						</set>
						<test op="EQ">
							<value>this.value</value>
							<value>Q</value>
							<set field="value">
								<entry value="QUEUED_ACTIVE"/>
							</set>
						</test>
						<test op="EQ">
							<value>this.value</value>
							<value>R</value>
							<set field="value">
								<entry value="RUNNING"/>
							</set>
						</test>
						<test op="EQ">
							<value>this.value</value>
							<value>S</value>
							<set field="value">
								<entry value="SUSPENDED"/>
							</set>
						</test>
						<test op="EQ">
							<value>this.value</value>
							<value>C</value>
							<set field="value">
								<entry value="COMPLETED"/>
							</set>
						</test>
						<test op="EQ">
							<value>this.value</value>
							<value>E</value>
							<set field="value">
								<entry value="COMPLETED"/>
							</set>
						</test>
						<test op="EQ">
							<value>this.value</value>
							<value>H</value>
							<set field="value">
								<entry value="SYSTEM_ON_HOLD"/>
							</set>
						</test>
					</match>
				</read>
			</stdout-parser>
		</get-job-status>
	</control-data>
	<monitor-data/>
</resource-manager-builder>