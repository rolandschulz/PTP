/*******************************************************************************
 * Copyright (c) 2009 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/

package org.eclipse.ptp.rm.mpi.openmpi.core.rtsystem;

import java.io.FilterInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.util.HashMap;
import java.util.Map;

/**
 * Attempt to clean up quasi-XML output by 1.3.x
 * 
 * We know the following:
 * - XML generated by 1.3.3 and below does not include a root element
 * - XML between the <map> and </map> tags should be well formed
 * - XML generated by 1.3.3 and below may embed bogus <stdout> tags or otherwise corrupt the XML
 *   after the </map> tag
 * - There may be non XML output before the first tag and after the final tag 
 * - Dstore connections interpret escaped &lt; and &gt; tags!
 * 
 * We need to:
 * - inject root tags if necessary
 * - ignore everything before the first and after the last XML tag
 * - for 1.3.3 and below (identified by lack of root element) the last XML tag is </map>
 * - check for invalid '<' and '>' characters and convert them back to the escaped forms
 * 
 */
public class OpenMPI13xInputStream extends FilterInputStream {
	protected class TagItem {
		private final String tag;
		
		public TagItem(String tag) {
			this.tag = tag;
		}
		
		public String tag() {
			return tag;
		}
	}
	
	protected class TagSet {
		private final int len;
		private HashMap<String, TagItem> tags = new HashMap<String, TagItem>();
		
		public TagSet(int len) {
			this.len = len;
		}
		
		public int length() {
			return len;
		}
	
		public TagItem add(String tag) {
			TagItem item = new TagItem(tag);
			tags.put(tag, item);
			return item;
		}

		public TagItem match(String str) {
			if (str.length() >= len) {
				return tags.get(str.substring(0, len));
			}
			return null;
		}
	}
	
	protected class TagList {
		private int longest = 0;
		private final HashMap<Integer, TagSet> tags = new HashMap<Integer, TagSet>();
		
		public TagItem add(String tag) {
			Integer len = Integer.valueOf(tag.length());
			TagSet set = tags.get(len);
			if (set == null) {
				set = new TagSet(len.intValue());
				tags.put(len, set);
			}
			TagItem item = set.add(tag);
			if (len.intValue() > longest) {
				longest = len.intValue();
			}
			return item;
		}
		
		public TagItem match(String str) {
			for (Map.Entry<Integer, TagSet> entry : tags.entrySet()) {
				TagItem item = entry.getValue().match(str);
				if (item != null) {
					return item;
				}
			}
			return null;
		}
		
		public int longest() {
			return longest;
		}
	}
	
	private final static String rootStartTagString = "<mpirun>"; //$NON-NLS-1$
	private final static String rootEndTagString = "</mpirun>"; //$NON-NLS-1$
	
	private final TagItem rootStartTag;
	private final TagList validStartTags = new TagList();
	private final TagList validTags = new TagList();
	private final TagList finalTags = new TagList();

	private enum State {
		PROLOG, 
		START_TAG,
		XML,
		SEEN_VALID,
		SEEN_FINAL,
		EPILOG
	}

	private State state = State.PROLOG;
	private boolean rootTag = true; // Assume root tag
	private StringBuilder buffer = new StringBuilder();
	
	protected OpenMPI13xInputStream(InputStream in) {
		super(in);
		rootStartTag = validStartTags.add(rootStartTagString);
		validStartTags.add("<map>"); //$NON-NLS-1$
		validTags.add("<map>"); //$NON-NLS-1$
		validTags.add("</map>"); //$NON-NLS-1$
		validTags.add("<host"); //$NON-NLS-1$
		validTags.add("</host>"); //$NON-NLS-1$
		validTags.add("<process"); //$NON-NLS-1$
		validTags.add("</process>"); //$NON-NLS-1$
		validTags.add("<stdout"); //$NON-NLS-1$
		validTags.add("</stdout>"); //$NON-NLS-1$
		validTags.add("<stderr"); //$NON-NLS-1$
		validTags.add("</stderr>"); //$NON-NLS-1$
		validTags.add("<stddiag"); //$NON-NLS-1$
		validTags.add("</stddiag>"); //$NON-NLS-1$
	}
	
	/* (non-Javadoc)
	 * @see java.io.FilterInputStream#available()
	 */
	@Override
	public int available() throws IOException {
		int available = 0;
		
		switch (state) {
		case PROLOG:
			available = rootStartTagString.length();
			break;
			
		case START_TAG:
			available = super.available();
			break;
			
		case XML:
		case SEEN_VALID:
		case SEEN_FINAL:
		case EPILOG:
			available = buffer.length() + super.available();
			break;
		}
		
		return available;
	}

	/* (non-Javadoc)
	 * @see java.io.FilterInputStream#markSupported()
	 */
	@Override
	public boolean markSupported() {
		return false;
	}

	/* (non-Javadoc)
	 * @see java.io.FilterInputStream#read()
	 */
	@Override
	public int read() throws IOException {
		while (state != State.EPILOG) {
			int ch = super.read();
			
			switch (state) {
			case PROLOG:
				// Ignore anything except a less-than
				if (ch < 0) {
					return -1;
				}
				if (ch == '<') {
					buffer.append((char)ch);
					state = State.START_TAG;
				}
				break;
				
			case START_TAG:
				// Find first valid tag. If we find another '<' then
				// assume the first '<' was bogus. If we find a '>'
				// then check the tag is valid. If not, start again.
				if (ch < 0) {
					return -1;
				}
				buffer.append((char)ch);
				switch (ch) {
				case '<':
					buffer.delete(0, buffer.length());
					state = State.PROLOG;
					break;
					
				case '>':
					TagItem item = validStartTags.match(buffer.toString());
					if (item != null) {
						if (item == rootStartTag) {
							finalTags.add(rootEndTagString);
						} else {
							finalTags.add("</map>"); //$NON-NLS-1$
							buffer.insert(0, rootStartTagString);
							rootTag = false;
						}
						state = State.SEEN_VALID;
					} else {
						buffer.delete(0, buffer.length());
						state = State.PROLOG;
					}
					break;
				}
				break;
				
			case XML:
				if (ch >= ' ') {
					// Skip imbedded newlines (bug #287204)
					buffer.append((char)ch);
				}
				if (buffer.length() == 0) {
					return -1;
				}
				ch = buffer.charAt(0);
				if (ch == '<') {
					String val = buffer.toString();
					
					// If tag is a possible final tag, need to check
					// following characters to determine if we're at 
					// end of XML
					if (finalTags.match(val) != null) {
						state = State.SEEN_FINAL;
						break;
					}
					
					// If tag is valid, just return the first saved char
					if (validTags.match(val) != null) {
						state = State.SEEN_VALID;
						break;
					}
					
					// If tag could still match one of the above, continue
					// to save characters.
					if (buffer.length() <= Math.max(validTags.longest(), finalTags.longest())) {
						break;
					}
						
					// Not a known tag, so replace with escape sequence (bug #286671)
					buffer.replace(0, 1, "&lt;"); //$NON-NLS-1$
					ch = buffer.charAt(0);
				} else if (ch == '>') {
					// Invalid tag end, replace it with escape sequence (bug #286671)
					buffer.replace(0, 1, "&gt;"); //$NON-NLS-1$
					ch = buffer.charAt(0);
				}
				buffer.deleteCharAt(0);
				return ch;
				
			case SEEN_VALID:
				// Process everything until we find the tag end
				if (ch >= ' ') {
					// Skip imbedded newlines (bug #287204)
					buffer.append((char)ch);
				}
				if (buffer.length() == 0) {
					return -1;
				}
				ch = buffer.charAt(0);
				buffer.deleteCharAt(0);
				if (ch == '>') {
					state = State.XML;
				}
				return ch;
				
			case SEEN_FINAL:
				// We've the final tag, insert root end tag if necessary
				if (ch >= ' ') {
					// Skip imbedded newlines (bug #287204)
					buffer.append((char)ch);
				}
				if (buffer.length() > 0) {
					ch = buffer.charAt(0);
					buffer.deleteCharAt(0);
					
					if (ch == '>') {
						if (!rootTag) {
							buffer.insert(0, rootEndTagString);
						}
						state = State.EPILOG;
					}
					return ch;
				}
				return -1;
				
			default:
				assert(false);
			}
		}
		
		if (buffer.length() == 0) {
			return -1;
		}
		int ch = buffer.charAt(0);
		buffer.deleteCharAt(0);
		return ch;
	}

	/* (non-Javadoc)
	 * @see java.io.FilterInputStream#read(byte[], int, int)
	 */
	@Override
	public int read(byte[] b, int off, int len) throws IOException {
		if (len == 0) {
			return 0;
		}

		int pos = off;
		
		/*
		 * Only read available bytes so that we return as soon as possible.
		 * If there are no bytes available, then we read at least one to
		 * block until more are available.
		 * 
		 * This allows the parser to update immediately there is data
		 * available, rather than waiting for the end of document.
		 */
		int avail = available();
		if (avail > len) {
			avail = len;
		} else if (avail == 0) {
			avail = 1;
		}
		
		for (int i = 0; i < avail; i++) {
			int ch = read();
			if (ch < 0) {
				if (i > 0) {
					// return the current buffer
					break;
				}
				return -1;
			}
			b[pos++] = (byte) (ch & 0xff);
		}
	
		return pos - off;
	}
}